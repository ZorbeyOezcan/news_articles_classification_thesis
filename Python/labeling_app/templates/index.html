<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Article Labeling App</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body class="start-screen">
    <div class="start-container">
        <h1>Article Labeling Tool</h1>

        {% if already_labeled > 0 %}
        <p class="info-text">You have <strong>{{ already_labeled }}</strong> articles already labeled.</p>
        {% endif %}

        <div class="mode-selection" id="mode-selection">
            <h2>What do you want to do?</h2>
            <div class="mode-buttons">
                <button class="mode-btn" id="btn-label-mode" onclick="selectMode('label')">Label new data</button>
                <button class="mode-btn" id="btn-clean-mode" onclick="selectMode('clean')">Clean already labelled data</button>
            </div>
        </div>

        <!-- ===== LABELING CONFIG ===== -->
        <div class="config-panel" id="config-panel" style="display: none;">
            <h2>Configure Labeling Session</h2>

            <div class="config-section">
                <h3>How many new data points do you want to label? (per class)</h3>
                <div class="target-mode-toggle">
                    <label>
                        <input type="radio" name="target-mode" value="uniform" checked onchange="toggleTargetMode()">
                        Uniform (same for all categories)
                    </label>
                    <label>
                        <input type="radio" name="target-mode" value="personalised" onchange="toggleTargetMode()">
                        Personalised (different per category)
                    </label>
                </div>

                <div id="uniform-input" class="target-input">
                    <label for="uniform-count">Target per category:</label>
                    <input type="number" id="uniform-count" min="1" value="100" class="number-input">
                </div>

                <div id="personalised-input" class="target-input" style="display: none;">
                    {% for cat in categories %}
                    <div class="personalised-row">
                        <label>{{ cat }}:</label>
                        <span class="existing-count">{{ category_counts.get(cat, 0) }} existing</span>
                        <input type="number" class="cat-target number-input" data-category="{{ cat }}" min="0" value="100">
                    </div>
                    {% endfor %}
                </div>

                <div class="normalise-section" id="normalise-section" style="display: none;">
                    <label class="checkbox-label">
                        <input type="checkbox" id="normalise-check" onchange="toggleNormalise()">
                        Normalise (bring every category to the same total)
                    </label>
                    <p class="hint-text">Set a target total per category. Session targets are calculated as: target - existing labels.</p>
                    <div id="normalise-input" style="display: none;">
                        <div class="normalise-target-row">
                            <label for="normalise-count">Target total per category:</label>
                            <input type="number" id="normalise-count" min="1" value="200" class="number-input" oninput="updateNormalisePreview()">
                        </div>
                        <div class="normalise-preview" id="normalise-preview">
                            {% for cat in categories %}
                            <div class="normalise-preview-row" data-category="{{ cat }}">
                                <span class="np-cat">{{ cat }}</span>
                                <span class="np-existing">{{ category_counts.get(cat, 0) }} existing</span>
                                <span class="np-needed" id="np-needed-{{ loop.index0 }}">--</span>
                            </div>
                            {% endfor %}
                        </div>
                    </div>
                </div>
            </div>

            <div class="config-section config-checkboxes">
                <label class="checkbox-label">
                    <input type="checkbox" id="domain-balanced" checked>
                    Same distribution by domain
                </label>
                <p class="hint-text">When checked, labeled articles will mirror the domain proportions of the full dataset.</p>

                <label class="checkbox-label">
                    <input type="checkbox" id="include-skipped">
                    Include skipped articles
                </label>
                <p class="hint-text">When checked, articles previously marked as "skipped" will appear again for labeling.</p>

                <label class="checkbox-label">
                    <input type="checkbox" id="include-not-clean">
                    Include articles needing cleaning
                </label>
                <p class="hint-text">When checked, articles previously marked as "not clean" will appear again for labeling.</p>
            </div>

            <button class="start-btn" onclick="startSession()">Start Labeling</button>
        </div>

        <!-- ===== CLEANING CONFIG ===== -->
        <div class="config-panel" id="clean-config-panel" style="display: none;">
            <h2>Configure Cleaning Session</h2>

            <div class="config-section">
                <h3>Choose data source</h3>
                <div class="clean-source-options">
                    <label class="clean-source-option {% if not clean_sources.umap.available %}disabled{% endif %}">
                        <input type="radio" name="clean-source" value="umap"
                            {% if not clean_sources.umap.available %}disabled{% endif %}
                            {% if clean_sources.umap.available %}checked{% endif %}>
                        <div class="source-info">
                            <span class="source-name">UMAP Outlier Analysis</span>
                            <span class="source-desc">Centroid Distance + Local Outlier Factor on embeddings</span>
                            {% if not clean_sources.umap.available %}
                            <span class="source-missing">Not available &mdash; run label_quality_check.ipynb first</span>
                            {% endif %}
                        </div>
                    </label>
                    <label class="clean-source-option {% if not clean_sources.cleanlab.available %}disabled{% endif %}">
                        <input type="radio" name="clean-source" value="cleanlab"
                            {% if not clean_sources.cleanlab.available %}disabled{% endif %}
                            {% if clean_sources.cleanlab.available and not clean_sources.umap.available %}checked{% endif %}>
                        <div class="source-info">
                            <span class="source-name">Cleanlab Label Issues</span>
                            <span class="source-desc">Confident Learning with per-class probabilities</span>
                            {% if not clean_sources.cleanlab.available %}
                            <span class="source-missing">Not available &mdash; run cleanlab_label_analysis.ipynb and copy output to cleanlab_output/</span>
                            {% endif %}
                        </div>
                    </label>
                </div>
            </div>

            <div class="config-section" id="umap-filter-section">
                <h3>Filter options</h3>
                <label class="checkbox-label">
                    <input type="checkbox" id="filter-both-methods">
                    Only show articles flagged by BOTH methods (Centroid + LOF)
                </label>
                <p class="hint-text">When unchecked, articles flagged by either method are shown.</p>
            </div>

            <div class="config-section" id="cleanlab-filter-section" style="display: none;">
                <h3>Filter options</h3>
                <label class="checkbox-label">
                    <input type="checkbox" id="filter-score-threshold" onchange="toggleScoreThreshold()">
                    Only show articles below quality score threshold
                </label>
                <div id="score-threshold-input" style="display: none; margin-top: 8px;">
                    <label for="score-threshold">Max quality score:</label>
                    <input type="number" id="score-threshold" min="0" max="1" step="0.05" value="0.5" class="number-input">
                </div>
            </div>

            <button class="start-btn" id="clean-start-btn" onclick="startCleaning()"
                {% if not clean_sources.umap.available and not clean_sources.cleanlab.available %}disabled{% endif %}>
                Start Cleaning
            </button>
            {% if not clean_sources.umap.available and not clean_sources.cleanlab.available %}
            <p class="hint-text" style="margin-top: 8px; color: #dc2626;">No quality check results found. Run one of the analysis notebooks first.</p>
            {% endif %}
        </div>
    </div>

    <script>
        const EXISTING_COUNTS = {{ category_counts | tojson }};
        const CATEGORIES = {{ categories | tojson }};

        let currentMode = null;

        function selectMode(mode) {
            currentMode = mode;
            // Update button styles
            document.getElementById('btn-label-mode').classList.toggle('active-mode', mode === 'label');
            document.getElementById('btn-clean-mode').classList.toggle('active-mode', mode === 'clean');

            // Show/hide config panels
            document.getElementById('config-panel').style.display = mode === 'label' ? 'block' : 'none';
            document.getElementById('clean-config-panel').style.display = mode === 'clean' ? 'block' : 'none';

            // Update source filter visibility
            if (mode === 'clean') {
                updateCleanFilterVisibility();
            }
        }

        function showConfig() {
            selectMode('label');
        }

        function updateCleanFilterVisibility() {
            const selected = document.querySelector('input[name="clean-source"]:checked');
            const source = selected ? selected.value : '';
            document.getElementById('umap-filter-section').style.display = source === 'umap' ? 'block' : 'none';
            document.getElementById('cleanlab-filter-section').style.display = source === 'cleanlab' ? 'block' : 'none';
        }

        // Listen for source radio changes
        document.querySelectorAll('input[name="clean-source"]').forEach(radio => {
            radio.addEventListener('change', updateCleanFilterVisibility);
        });

        function toggleScoreThreshold() {
            const checked = document.getElementById('filter-score-threshold').checked;
            document.getElementById('score-threshold-input').style.display = checked ? 'block' : 'none';
        }

        function toggleTargetMode() {
            const mode = document.querySelector('input[name="target-mode"]:checked').value;
            document.getElementById('uniform-input').style.display = mode === 'uniform' ? 'block' : 'none';
            document.getElementById('personalised-input').style.display = mode === 'personalised' ? 'block' : 'none';
            document.getElementById('normalise-section').style.display = mode === 'personalised' ? 'block' : 'none';
        }

        function toggleNormalise() {
            const checked = document.getElementById('normalise-check').checked;
            document.getElementById('normalise-input').style.display = checked ? 'block' : 'none';
            document.querySelectorAll('.cat-target').forEach(input => {
                input.disabled = checked;
                input.style.opacity = checked ? '0.4' : '1';
            });
            if (checked) updateNormalisePreview();
        }

        function updateNormalisePreview() {
            const target = parseInt(document.getElementById('normalise-count').value) || 0;
            CATEGORIES.forEach((cat, idx) => {
                const existing = EXISTING_COUNTS[cat] || 0;
                const needed = Math.max(0, target - existing);
                const el = document.getElementById('np-needed-' + idx);
                if (el) {
                    if (needed === 0) {
                        el.textContent = 'already met (' + existing + '/' + target + ')';
                        el.className = 'np-needed np-met';
                    } else {
                        el.textContent = needed + ' needed (' + existing + '/' + target + ')';
                        el.className = 'np-needed np-remaining';
                    }
                }
            });
        }

        async function startSession() {
            const mode = document.querySelector('input[name="target-mode"]:checked').value;
            const domainBalanced = document.getElementById('domain-balanced').checked;
            const includeSkipped = document.getElementById('include-skipped').checked;
            const includeNotClean = document.getElementById('include-not-clean').checked;

            let config = {
                mode: mode,
                domain_balanced: domainBalanced,
                include_skipped: includeSkipped,
                include_not_clean: includeNotClean
            };

            if (mode === 'uniform') {
                const count = parseInt(document.getElementById('uniform-count').value);
                if (!count || count < 1) {
                    alert('Please enter a valid target count.');
                    return;
                }
                config.count = count;
            } else {
                const normalise = document.getElementById('normalise-check').checked;
                if (normalise) {
                    const normCount = parseInt(document.getElementById('normalise-count').value);
                    if (!normCount || normCount < 1) {
                        alert('Please enter a valid normalise target.');
                        return;
                    }
                    config.normalise = true;
                    config.normalise_count = normCount;
                } else {
                    const targets = {};
                    document.querySelectorAll('.cat-target').forEach(input => {
                        targets[input.dataset.category] = parseInt(input.value) || 0;
                    });
                    config.targets = targets;
                }
            }

            const resp = await fetch('/start-session', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(config)
            });

            if (resp.ok) {
                window.location.href = '/label';
            } else {
                alert('Failed to start session.');
            }
        }

        async function startCleaning() {
            const sourceEl = document.querySelector('input[name="clean-source"]:checked');
            if (!sourceEl) {
                alert('Please select a data source.');
                return;
            }

            const source = sourceEl.value;
            let config = { source: source };

            if (source === 'umap') {
                config.filter_both_methods = document.getElementById('filter-both-methods').checked;
            } else if (source === 'cleanlab') {
                const useThreshold = document.getElementById('filter-score-threshold').checked;
                if (useThreshold) {
                    config.score_threshold = parseFloat(document.getElementById('score-threshold').value) || 0.5;
                }
            }

            const resp = await fetch('/start-cleaning', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(config)
            });

            if (resp.ok) {
                const data = await resp.json();
                if (data.total_flagged === 0) {
                    alert('No flagged articles found with the selected filters.');
                    return;
                }
                window.location.href = '/clean';
            } else {
                alert('Failed to start cleaning session.');
            }
        }
    </script>
</body>
</html>
