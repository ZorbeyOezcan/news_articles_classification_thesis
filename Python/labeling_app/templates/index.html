<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Article Labeling App</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body class="start-screen">
    <div class="start-container">
        <h1>Article Labeling Tool</h1>

        {% if already_labeled > 0 %}
        <p class="info-text">You have <strong>{{ already_labeled }}</strong> articles already labeled.</p>
        {% endif %}

        <div class="mode-selection" id="mode-selection">
            <h2>What do you want to do?</h2>
            <div class="mode-buttons">
                <button class="mode-btn active-mode" onclick="showConfig()">Label new data</button>
                <button class="mode-btn disabled-mode" disabled title="Coming soon">Clean already labelled data</button>
            </div>
        </div>

        <div class="config-panel" id="config-panel" style="display: none;">
            <h2>Configure Labeling Session</h2>

            <div class="config-section">
                <h3>How many new data points do you want to label? (per class)</h3>
                <div class="target-mode-toggle">
                    <label>
                        <input type="radio" name="target-mode" value="uniform" checked onchange="toggleTargetMode()">
                        Uniform (same for all categories)
                    </label>
                    <label>
                        <input type="radio" name="target-mode" value="personalised" onchange="toggleTargetMode()">
                        Personalised (different per category)
                    </label>
                </div>

                <div id="uniform-input" class="target-input">
                    <label for="uniform-count">Target per category:</label>
                    <input type="number" id="uniform-count" min="1" value="100" class="number-input">
                </div>

                <div id="personalised-input" class="target-input" style="display: none;">
                    {% for cat in categories %}
                    <div class="personalised-row">
                        <label>{{ cat }}:</label>
                        <span class="existing-count">{{ category_counts.get(cat, 0) }} existing</span>
                        <input type="number" class="cat-target number-input" data-category="{{ cat }}" min="0" value="100">
                    </div>
                    {% endfor %}
                </div>

                <div class="normalise-section" id="normalise-section" style="display: none;">
                    <label class="checkbox-label">
                        <input type="checkbox" id="normalise-check" onchange="toggleNormalise()">
                        Normalise (bring every category to the same total)
                    </label>
                    <p class="hint-text">Set a target total per category. Session targets are calculated as: target - existing labels.</p>
                    <div id="normalise-input" style="display: none;">
                        <div class="normalise-target-row">
                            <label for="normalise-count">Target total per category:</label>
                            <input type="number" id="normalise-count" min="1" value="200" class="number-input" oninput="updateNormalisePreview()">
                        </div>
                        <div class="normalise-preview" id="normalise-preview">
                            {% for cat in categories %}
                            <div class="normalise-preview-row" data-category="{{ cat }}">
                                <span class="np-cat">{{ cat }}</span>
                                <span class="np-existing">{{ category_counts.get(cat, 0) }} existing</span>
                                <span class="np-needed" id="np-needed-{{ loop.index0 }}">--</span>
                            </div>
                            {% endfor %}
                        </div>
                    </div>
                </div>
            </div>

            <div class="config-section config-checkboxes">
                <label class="checkbox-label">
                    <input type="checkbox" id="domain-balanced" checked>
                    Same distribution by domain
                </label>
                <p class="hint-text">When checked, labeled articles will mirror the domain proportions of the full dataset.</p>

                <label class="checkbox-label">
                    <input type="checkbox" id="include-skipped">
                    Include skipped articles
                </label>
                <p class="hint-text">When checked, articles previously marked as "skipped" will appear again for labeling.</p>

                <label class="checkbox-label">
                    <input type="checkbox" id="include-not-clean">
                    Include articles needing cleaning
                </label>
                <p class="hint-text">When checked, articles previously marked as "not clean" will appear again for labeling.</p>
            </div>

            <button class="start-btn" onclick="startSession()">Start Labeling</button>
        </div>
    </div>

    <script>
        function showConfig() {
            document.getElementById('config-panel').style.display = 'block';
        }

        const EXISTING_COUNTS = {{ category_counts | tojson }};
        const CATEGORIES = {{ categories | tojson }};

        function toggleTargetMode() {
            const mode = document.querySelector('input[name="target-mode"]:checked').value;
            document.getElementById('uniform-input').style.display = mode === 'uniform' ? 'block' : 'none';
            document.getElementById('personalised-input').style.display = mode === 'personalised' ? 'block' : 'none';
            document.getElementById('normalise-section').style.display = mode === 'personalised' ? 'block' : 'none';
        }

        function toggleNormalise() {
            const checked = document.getElementById('normalise-check').checked;
            document.getElementById('normalise-input').style.display = checked ? 'block' : 'none';
            // Disable individual inputs when normalise is on
            document.querySelectorAll('.cat-target').forEach(input => {
                input.disabled = checked;
                input.style.opacity = checked ? '0.4' : '1';
            });
            if (checked) updateNormalisePreview();
        }

        function updateNormalisePreview() {
            const target = parseInt(document.getElementById('normalise-count').value) || 0;
            CATEGORIES.forEach((cat, idx) => {
                const existing = EXISTING_COUNTS[cat] || 0;
                const needed = Math.max(0, target - existing);
                const el = document.getElementById('np-needed-' + idx);
                if (el) {
                    if (needed === 0) {
                        el.textContent = 'already met (' + existing + '/' + target + ')';
                        el.className = 'np-needed np-met';
                    } else {
                        el.textContent = needed + ' needed (' + existing + '/' + target + ')';
                        el.className = 'np-needed np-remaining';
                    }
                }
            });
        }

        async function startSession() {
            const mode = document.querySelector('input[name="target-mode"]:checked').value;
            const domainBalanced = document.getElementById('domain-balanced').checked;
            const includeSkipped = document.getElementById('include-skipped').checked;
            const includeNotClean = document.getElementById('include-not-clean').checked;

            let config = {
                mode: mode,
                domain_balanced: domainBalanced,
                include_skipped: includeSkipped,
                include_not_clean: includeNotClean
            };

            if (mode === 'uniform') {
                const count = parseInt(document.getElementById('uniform-count').value);
                if (!count || count < 1) {
                    alert('Please enter a valid target count.');
                    return;
                }
                config.count = count;
            } else {
                const normalise = document.getElementById('normalise-check').checked;
                if (normalise) {
                    const normCount = parseInt(document.getElementById('normalise-count').value);
                    if (!normCount || normCount < 1) {
                        alert('Please enter a valid normalise target.');
                        return;
                    }
                    config.normalise = true;
                    config.normalise_count = normCount;
                } else {
                    const targets = {};
                    document.querySelectorAll('.cat-target').forEach(input => {
                        targets[input.dataset.category] = parseInt(input.value) || 0;
                    });
                    config.targets = targets;
                }
            }

            const resp = await fetch('/start-session', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(config)
            });

            if (resp.ok) {
                window.location.href = '/label';
            } else {
                alert('Failed to start session.');
            }
        }
    </script>
</body>
</html>
